<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applicant Profiles</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
        }
    
        .header {
            background-color: #f8f9fa;
            color: #333;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    
        .header-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }
        
        .header-row h2 {
            margin: 0;
            font-size: 1.2em;
            color: #555;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.8em;
            color: #555;
        }
    
        .header h2 {
            margin: 5px 0 0 0;
            font-size: 1.2em;
            font-weight: normal;
            color: #777;
        }
    
        .role-description {
            max-width: 800px;
            margin: 20px auto;
            padding: 10px 20px; 
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            color: #333;
            line-height: 1.6;
        }
    
        .role-description strong {
            font-size: 1.1em;
            color: #555;
        }
    
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* Increased the gap between cards for better spacing */
            justify-content: center;
            padding: 20px;
            position: relative;
            overflow: visible;
        }
    
        .profile-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: visible; /* Prevent clipping of tooltip within the card */
            width: 220px; /* Slightly increased width for better readability */
            display: flex;
            flex-direction: column;
            position: relative; /* Ensure tooltip respects this card's positioning */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 1; /* Ensure card has a default stacking context */
        }
    
        .profile-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
    
        .profile-card.invited {
            opacity: 0.6;
            pointer-events: none;
        }
    
        .profile-header {
            background-color: #f0f0f0;
            color: #333;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
        }
    
        .badge-container {
            height: 30px;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 10px;
        }
    
        .badge-yellow {
            background-color: #FFFACD;
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 100px;
            text-align: center;
        }
    
        .badge-green {
            background-color: #DFF2BF;
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 100px;
            text-align: center;
        }
    
        .profile-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
        }
    
        .profile-section div {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
    
        .profile-section div span:first-child {
            font-weight: bold;
        }
    
        .skills, .prediction-section, .invite-section {
            padding: 10px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
        }
    
        .invite-section {
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    
        .accordion-header {
            cursor: pointer;
            color: #007BFF;
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 0;
        }
    
        .accordion-content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    
        .accordion-content.active {
            display: flex;
        }
    
        .accordion-content div {
            margin-bottom: 5px;
        }
    
        .info-icon {
            margin-left: 5px;
            font-size: 0.9em;
            color: #888;
            cursor: pointer;
            position: relative; /* Ensure tooltip is positioned relative to the icon */
            z-index: 2; /* Tooltip is above other cards */
        }
    
        .info-icon:hover::after {
            content: "These values represent the impact of features on the AI's decision-making process. Higher values indicate stronger influence.";
            position: absolute;
            top: -60px;
            left: 50%; /* Center the tooltip horizontally */
            transform: translateX(-50%); /* Adjust for tooltip width */
            background-color: #fff;
            color: #333;
            font-size: 0.8em;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px;
            width: 250px; /* Increased width for better readability */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000; /* Ensure tooltip is above other cards */
            white-space: normal;
            pointer-events: none;
        }
    
        .info-icon:hover {
            z-index: 1000; /* Bring the icon and tooltip above all cards */
        }
    
        .stars {
            color: #000;
        }
    
        .invite-btn {
            padding: 5px 10px;
            border: none;
            background-color: #FFFACD;
            color: #333;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em; 
            transition: background-color 0.3s ease;
        }
    
        .invite-btn.highlight-btn {
            background-color: #FFECB3;
        }
    
        .invite-btn.highlight-btn:hover {
            background-color: #FFE082;
        }
    
        .hoverable-feature {
            position: relative;
            cursor: pointer;
            color: #007BFF;
            text-decoration: underline dotted;
        }
    
        .hoverable-feature:hover::after {
            content: attr(title); /* Tooltip content from title attribute */
            position: absolute;
            top: -35px; /* Position the tooltip above the text */
            left: 50%; /* Center tooltip horizontally */
            transform: translateX(-50%); /* Ensure proper alignment */
            background-color: #fff;
            color: #333;
            font-size: 0.8em;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px 10px;
            width: 280px; /* Increased tooltip width */
            white-space: normal; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        .recommendation-manipulation {
            padding: 15px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
            margin-top: 15px;
            border-radius: 8px;
        }

        .manipulation-columns {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .manipulation-column {
            width: 30%; /* Ensure 3 columns fit in one row */
        }

        .manipulation-column h5 {
            margin-bottom: 10px;
            font-size: 1em;
            color: #555;
        }

        .manipulation-column label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
        }

        .manipulation-column input[type="radio"] {
            margin-right: 5px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
            cursor: pointer;
        }

        button.highlighted {
            background-color: #f0f8ff; /* Light blue background */
            color: #333; /* Text color */
            border: 2px solid #007bff; /* Blue border */
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5); /* Glow effect */
            transition: all 0.3s ease; /* Smooth transition for the highlight */
        }

        label.disabled {
            opacity: 0.5; /* Grey out the label */
            pointer-events: none; /* Prevent interaction */
            cursor: not-allowed; /* Show a "not-allowed" cursor */
        }

        .good-fit-no {
            color: red;
            font-weight: bold;
        }

        .probability-low {
            color: red;
            font-weight: bold;
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .modal h2 {
            margin: 0 0 10px;
        }

        .modal button {
            padding: 10px 20px;
            border: none;
            background: #007BFF;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        .modal button:hover {
            background: #0056b3;
        }

        .next-round-btn {
            padding: 10px 15px;
            background-color: #007BFF;
            color: white;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .next-round-btn:hover {
            background-color: #0056b3;
        }


    </style>
    
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>Applicant Profiles</h1>
            <div class="header-row">
                <button class="next-round-btn" onclick="nextRound()">Next Round</button>
                <h2>Role - Production Technician</h2>
                <h2 id="invite-counter">Applicants invited: 0/2 ¬∑ Round: 1/6</h2>
            </div>            
        </div>
    </div>    

    <div class="role-description">
        <p>
            <strong>Role Description:</strong> A Production Technician is responsible for operating and monitoring production equipment, ensuring efficient and safe manufacturing processes. Key responsibilities include maintaining quality standards, troubleshooting issues, and adhering to safety protocols.
        </p>
    </div>

    <div class="container" id="profiles">
        <!-- Profiles will be injected here -->
    </div>

    <script>
        let invitedCount = 0;
        const maxInvites = 2;
        const maxRounds = 6;
        let currentRound = parseInt(localStorage.getItem("currentRound")) || 1;
        let invitedCandidates = JSON.parse(localStorage.getItem("invitedCandidates")) || [];
        let isFetching = false;  // Global lock to prevent duplicate calls

        async function updatePrediction(candidateId, gender, age, race) {
            const updatePayload = {
                candidate_id: candidateId,
                updated_features: {
                    Sex: gender === "Female" ? 0 : 1,
                    Age: getRandomAge(age),
                }
            };

            // Reset all race values to 0
            const raceColumnMap = {
                "Black": "RaceDesc_Black or African American",
                "White": "RaceDesc_White",
                "Asian": "RaceDesc_Asian",
                "American Indian": "RaceDesc_American Indian or Alaska Native",
                "Hispanic": "RaceDesc_Hispanic"
            };
            Object.values(raceColumnMap).forEach(raceKey => updatePayload.updated_features[raceKey] = 0);

            // Set the selected race to 1
            if (raceColumnMap[race]) {
                updatePayload.updated_features[raceColumnMap[race]] = 1;
            }

            console.log("üì§ Sending request to backend:", JSON.stringify(updatePayload));

            try {
                const response = await fetch("/predict/update", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(updatePayload)
                });

                console.log("üîÑ Waiting for backend response...");

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("‚ùå Backend returned an error:", errorText);
                    throw new Error("Failed to update prediction.");
                }

                const result = await response.json();
                console.log("‚úÖ Backend response:", result);

                // Fetch feature descriptions
                const featureDescriptions = await fetchFeatureDescriptions();

                // Find the correct candidate profile card
                const candidateCard = document.querySelector(`.profile-card[data-candidate-id="${candidateId}"]`);
                if (!candidateCard) {
                    console.error("‚ùå Candidate card not found for ID:", candidateId);
                    return;
                }

                // Update the Good Fit section correctly
                const goodFitElement = candidateCard.querySelector(".prediction-section strong:nth-of-type(1)");
                if (goodFitElement) {
                    goodFitElement.nextSibling.nodeValue = ` ${result.is_good_fit ? "Yes" : "No"}`;
                    if (!result.is_good_fit) {
                        goodFitElement.classList.add("good-fit-no"); // Apply red color for "No"
                    } else {
                        goodFitElement.classList.remove("good-fit-no"); // Remove red color for "Yes"
                    }
                }

                // Update the Probability correctly
                const probabilityElement = candidateCard.querySelector(".prediction-section div:nth-of-type(2) strong");
                if (probabilityElement) {
                    probabilityElement.nextSibling.nodeValue = ` ${result.prediction_probability.toFixed(2)}`;
                    if (result.prediction_probability < 0.5) {
                        probabilityElement.classList.add("probability-low"); // Apply red color for low probability
                    } else {
                        probabilityElement.classList.remove("probability-low"); // Remove red color if above threshold
                    }
                }   

                // Update the AI Recommendation Badge (Add/Remove)
                const badgeContainer = candidateCard.querySelector(".badge-container");
                if (result.is_good_fit) {
                    // Add AI Recommendation badge if it doesn't exist
                    if (!badgeContainer.querySelector(".badge-yellow")) {
                        badgeContainer.innerHTML = `<div class="badge-yellow">AI Recommendation</div>`;
                    }
                } else {
                    // Remove AI Recommendation badge if Good Fit is No
                    const aiBadge = badgeContainer.querySelector(".badge-yellow");
                    if (aiBadge) {
                        aiBadge.remove();
                    }
                }

                // Update the XAI explanation
                const xaiSection = candidateCard.querySelector(".accordion-content");
                if (xaiSection) {
                    const description = featureDescriptions[feature.Feature] || "No description available.";

                    xaiSection.innerHTML = result.top_features.map(feature => `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span class="hoverable-feature" title="${description}">
                                ${feature.Feature}:
                            </span>
                            <span>${feature["SHAP Value"].toFixed(2)}</span>
                        </div>
                    `).join('');
                }

            } catch (error) {
                console.error("üö® Fetch error:", error);
            }
        }

        function getRandomAge(ageRange) {
            const ranges = {
                "20-30": [20, 30],
                "30-40": [30, 40],
                "40-50": [40, 50],
                ">60": [61, 75]
            };

            if (ranges[ageRange]) {
                const [min, max] = ranges[ageRange];
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            return 35; // Default fallback
        }

        async function handleManipulationChange(candidateId, selectedGroup, selectedValue, originalValues) {
            console.log("üîπ handleManipulationChange triggered", candidateId, selectedGroup, selectedValue);

            const allInputs = document.querySelectorAll(`input[name^="gender-${candidateId}"], 
                                                        input[name^="age-${candidateId}"], 
                                                        input[name^="race-${candidateId}"]`);

            // Get the original values
            const originalGender = originalValues.gender;
            const originalAge = originalValues.age;
            const originalRace = originalValues.race;

            // Check if a radio button is selected before accessing `.value`
            const genderInput = document.querySelector(`input[name="gender-${candidateId}"]:checked`);
            const ageInput = document.querySelector(`input[name="age-${candidateId}"]:checked`);
            const raceInput = document.querySelector(`input[name="race-${candidateId}"]:checked`);

            console.log(`üü¢ Found selections - Gender: ${genderInput ? genderInput.value : "‚ùå MISSING"}, Age: ${ageInput ? ageInput.value : "‚ùå MISSING"}, Race: ${raceInput ? raceInput.value : "‚ùå MISSING"}`);

            // If any input is missing, log an error and return
            if (!genderInput || !ageInput || !raceInput) {
                console.error(`‚ö†Ô∏è Missing input selection for candidate ${candidateId}`);
                return;
            }

            const currentGender = genderInput.value;
            const currentAge = ageInput.value;
            const currentRace = raceInput.value;

            console.log("Current selections:", currentGender, currentAge, currentRace);

            const isReverted = currentGender === originalGender && currentAge === originalAge && currentRace === originalRace;

            if (!isReverted) {
                console.log("Modifications detected, updating prediction...");
                allInputs.forEach(input => {
                    if (input.name.includes(selectedGroup) || input.value === originalValues[selectedGroup]) return;
                    input.disabled = true;
                    input.parentElement.classList.add("disabled");
                });

                await updatePrediction(candidateId, currentGender, currentAge, currentRace);
            } else {
                console.log("Values reverted, enabling inputs...");
                allInputs.forEach(input => {
                    input.disabled = false;
                    input.parentElement.classList.remove("disabled");
                });

                await updatePrediction(candidateId, originalGender, originalAge, originalRace);
            }
        }

        document.addEventListener("change", function (event) {
            if (event.target.type === "radio") {
                const candidateId = event.target.name.split('-')[1]; // Extract Candidate_ID
                const selectedGroup = event.target.name.split('-')[0]; // e.g., "gender", "age", "race"
                const selectedValue = event.target.value;

                // Find the profile card and get the original values
                const card = event.target.closest('.profile-card');
                if (!card) return;

                const originalValues = {
                    gender: card.dataset.originalGender,
                    age: card.dataset.originalAge,
                    race: card.dataset.originalRace,
                };

                handleManipulationChange(candidateId, selectedGroup, selectedValue, originalValues);
            }
        });

        document.addEventListener("DOMContentLoaded", function () {
            document.querySelectorAll(".accordion-content").forEach(content => {
                content.classList.add("active"); // Ensures all accordions start open
            });
        });

        async function fetchCandidates() {
            try {
                if (isFetching) {
                    console.warn("üö´ Skipping duplicate fetchCandidates call.");
                    return; // Prevent a second call
                }

                isFetching = true; // Set the lock

                if (currentRound > maxRounds) { // üîÑ Check if max rounds exceeded
                    console.log("üèÅ Max rounds reached. Resetting to Round 1.");
                    currentRound = 1; // üîÑ Reset to 1 if all rounds are completed
                    localStorage.setItem("currentRound", currentRound);
                    disableAllInvites();
                    showCompletionDialog();
                    return; // Stop fetching candidates
                }

                // Retrieve the seenCandidates list
                let seenCandidates = JSON.parse(localStorage.getItem("seenCandidates")) || [];
                let invitedCandidates = JSON.parse(localStorage.getItem("invitedCandidates")) || [];
                console.log("üìå LocalStorage seenCandidates:", JSON.parse(localStorage.getItem("seenCandidates")) || []);
                console.log("üìå LocalStorage invitedCandidates:", JSON.parse(localStorage.getItem("invitedCandidates")) || []);

                // Combine seen and invited candidates for exclusion
                let excludeList = [...new Set(seenCandidates.concat(invitedCandidates))];

                console.log("üì§ Fetching candidates. Excluding:", excludeList);

                // ‚úÖ Ensure we send exclude correctly formatted
                const queryString = excludeList.length > 0 
                    ? `?exclude=${excludeList.join("&exclude=")}` 
                    : "";

                // Fetch candidates and feature descriptions in parallel
                const [candidatesResponse, featureDescriptions] = await Promise.all([
                    fetch(`/candidates/data${queryString}`).then(res => res.json()), // Fetch candidates
                    fetchFeatureDescriptions() // Fetch feature descriptions
                ]);

                // Handle errors if candidates response fails
                if (!candidatesResponse) {
                    throw new Error("Failed to fetch candidates.");
                }

                const data = candidatesResponse; // Assign the JSON response

                // Extract new candidate IDs
                let newSeenCandidates = data.map(c => c.Candidate_ID);
                
                // Ensure `seenCandidates` updates correctly
                seenCandidates = [...new Set([...seenCandidates, ...newSeenCandidates])]; 
                localStorage.setItem("seenCandidates", JSON.stringify(seenCandidates));

                // Update UI
                updateInviteCounter();

                // Select the container where profiles will be displayed
                const profilesContainer = document.getElementById('profiles');
                profilesContainer.innerHTML = ''; // Clear previous content
                        
                // Store the newly fetched candidates as "seen"
                let currentRoundCandidates = data.map(c => c.Candidate_ID);
                // localStorage.setItem("seenCandidates", JSON.stringify([...new Set(seenCandidates.concat(currentRoundCandidates))]));

                // Iterate through each candidate
                data.forEach(candidate => {
                    const card = document.createElement('div');
                    card.setAttribute('data-candidate-id', candidate.Candidate_ID);
                    card.className = 'profile-card';

                    // Store the original values in data attributes
                    card.dataset.originalGender = candidate.Gender;
                    card.dataset.originalAge = getAgeBin(candidate.Age);
                    card.dataset.originalRace = candidate.Race;

                    // Add AI Recommendation badge if applicable
                    const badge = candidate.GoodFit
                        ? `<div class="badge-yellow">AI Recommendation</div>`
                        : "";

                    // Generate accordion content for XAI features
                    const accordionContent = candidate.GoodFit
                        ? generateAccordionContent(candidate, featureDescriptions)
                        : '';

                    // Build the card HTML
                    card.innerHTML = `
                        <div class="profile-header">
                            <span>${candidate.Prename} ${candidate.Name}</span>
                        </div>
                        <div class="badge-container">${badge}</div>

                        <div class="profile-section">
                            <div>
                                <span>Name:</span>
                                <span>${candidate.Name}</span>
                            </div>
                            <div>
                                <span>Prename:</span>
                                <span>${candidate.Prename}</span>
                            </div>
                            <div>
                                <span>Gender:</span>
                                <span>${candidate.Gender}</span>
                            </div>
                            <div>
                                <span>Age:</span>
                                <span>${candidate.Age || 'N/A'}</span>
                            </div>
                            <div>
                                <span>Nationality:</span>
                                <span>${candidate.Nationality || 'N/A'}</span>
                            </div>
                            <div>
                                <span>Birthplace:</span>
                                <span>${candidate.Birthplace || 'N/A'}</span>
                            </div>
                        </div>

                        <div class="skills">
                            <h4>Skills:</h4>
                            ${Object.entries(candidate.Skills).map(([skill, stars]) => `
                                <div style="display: flex; justify-content: space-between;">
                                    <span>${skill}</span>
                                    <span class="stars">${'‚òÖ'.repeat(stars)}${'‚òÜ'.repeat(5 - stars)}</span>
                                </div>
                            `).join('')}
                        </div>

                        <div class="invite-section"></div> <!-- Invite button will be appended here -->

                        <div class="prediction-section">
                            <div>
                                <strong>Good Fit?:</strong> ${candidate.GoodFit ? "Yes" : "No"}
                            </div>
                            <div>
                                <strong>Probability:</strong> ${candidate.Probability ? candidate.Probability.toFixed(2) : "0.00"}
                            </div>
                        </div>

                        ${accordionContent}

                        ${candidate.GoodFit ? `
                            <div class="recommendation-manipulation">
                                <h4>Manipulate AI Recommendation:</h4>
                                <strong>Take a look at how the recommendation changes when you manipulate protected data:</strong>
                                <div class="manipulation-columns">
                                    <div class="manipulation-column">
                                        <h5>Gender</h5>
                                        ${["Male", "Female"].map(value => `
                                            <label>
                                                <input type="radio" name="gender-${candidate.Candidate_ID}" value="${value}"
                                                    ${candidate.Gender === value ? "checked" : ""}>
                                                ${value}
                                            </label>
                                        `).join('')}
                                    </div>

                                    <div class="manipulation-column">
                                        <h5>Age</h5>
                                        ${["20-30", "30-40", "40-50", "50-60", ">60"].map(value => `
                                            <label>
                                                <input type="radio" name="age-${candidate.Candidate_ID}" value="${value}"
                                                    ${getAgeBin(candidate.Age) === value ? "checked" : ""}>
                                                ${value} years
                                            </label>
                                        `).join('')}
                                    </div>

                                    <div class="manipulation-column">
                                        <h5>Race</h5>
                                        ${["Black", "White", "Asian"].map(value => `
                                            <label>
                                                <input type="radio" name="race-${candidate.Candidate_ID}" value="${value}"
                                                    ${candidate.Race === value ? "checked" : ""}>
                                                ${value}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        ` : ""}

                    `;

                    // **Create Invite Button**
                    const inviteButton = document.createElement("button");
                        inviteButton.className = candidate.GoodFit ? "invite-btn highlight-btn" : "invite-btn";
                        inviteButton.textContent = candidate.GoodFit ? ">>Invite Applicant<<" : "Invite Applicant";
                        inviteButton.addEventListener("click", function () {
                            inviteCandidate(candidate.Candidate_ID, inviteButton);
                        });

                    // Append the invite button to the card
                    card.querySelector(".invite-section").appendChild(inviteButton);

                    // Append the card to the profiles container
                    profilesContainer.appendChild(card);
                });

                if (currentRound > maxRounds) {
                    disableAllInvites();
                    showCompletionDialog();
                }

            } catch (error) {
                console.error('Error fetching candidates:', error);
            } finally {
                isFetching = false; // Unlock after fetch completes
            }
        }

        // Helper function to fetch feature descriptions
        async function fetchFeatureDescriptions() {
            try {
                const response = await fetch('/data/feature_description.json');
                if (!response.ok) {
                    throw new Error('Failed to load feature descriptions');
                }
                return await response.json(); // Parse and return JSON
            } catch (error) {
                console.error('Error fetching feature descriptions:', error);
                return {};
            }
        }

        function generateAccordionContent(candidate, featureDescriptions) {
            if (!candidate.GoodFit) return '';

            return `
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    XAI: Top 3 Features
                    <span class="info-icon" title="These values represent the top factors influencing the AI's decision-making.">‚Ñπ</span>
                </div>
                <div class="accordion-content">
                    ${candidate.TopFeatures.map(feature => {
                        const description = featureDescriptions[feature.Feature] || 'No description available.';
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span 
                                    class="hoverable-feature" 
                                    title="${description}">
                                    ${feature.Feature}:
                                </span>
                                <span>${feature["SHAP Value"].toFixed(2)}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
        
        async function inviteCandidate(candidateId, button) {
            if (currentRound > maxRounds) {
                disableAllInvites();
                showCompletionDialog();
                return;
            }

            const card = button.closest('.profile-card');
            if (!card) {
                console.error("‚ö†Ô∏è No profile card found for this button.");
                return;
            }

            if (!candidateId) {
                console.error("‚ö†Ô∏è Candidate ID missing on the profile card.");
                return;
            }

            if (invitedCount < maxInvites) {
                card.classList.add('invited');
                button.outerHTML = `<div class="badge-green">Invited</div>`;

                invitedCount++;
                invitedCandidates.push(candidateId);
                localStorage.setItem("invitedCandidates", JSON.stringify([...new Set(invitedCandidates)]));

                // Send to backend for persistence
                try {
                    const response = await fetch("/candidates/invite", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ candidate_id: candidateId })
                    });

                    if (!response.ok) {
                        console.error("‚ùå Error inviting candidate:", await response.text());
                    } else {
                        console.log(`‚úÖ Candidate ${candidateId} invited successfully.`);
                    }
                } catch (error) {
                    console.error("üö® Fetch error:", error);
                }

                updateInviteCounter();

                console.log(`‚úÖ Candidate ${candidateId} invited.`);

                if (invitedCount >= maxInvites) {
                    if (currentRound < maxRounds) { 
                        currentRound++; 
                        localStorage.setItem("currentRound", currentRound);
                    } else {
                        currentRound = maxRounds + 1;
                        localStorage.setItem("currentRound", currentRound);
                    }

                    updateInviteCounter();
                    setTimeout(fetchCandidates, 1000);
                }
            } else {
                alert('Maximum number of applicants invited!');
            }
        }

        function disableAllInvites() {
            document.querySelectorAll(".invite-btn").forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = "0.5";
                btn.style.cursor = "not-allowed";
            });
        }

        function showCompletionDialog() {
            // Check if the modal already exists to prevent duplicate modals
            if (document.querySelector(".modal-overlay")) return;

            const profilesContainer = document.getElementById('profiles');
            profilesContainer.innerHTML = `
                <div class="completion-message">
                    <h2>All Candidates Selected</h2>
                    <p>Thank you for your participation.</p>
                    <button onclick="closeCompletionDialog()">OK</button>
                </div>
            `;
        }

        function closeCompletionDialog() {
            const profilesContainer = document.getElementById('profiles');
            profilesContainer.innerHTML = ""; // Clear the content when OK is pressed
        }

        function updateInviteCounter() {
            // Ensure the counter does not exceed max limits
            const displayedInvitedCount = Math.min(invitedCount, maxInvites);
            const displayedRound = Math.min(currentRound, maxRounds);

            document.getElementById('invite-counter').textContent = 
                `Applicants invited: ${displayedInvitedCount}/${maxInvites} ¬∑ Round: ${displayedRound}/${maxRounds}`;

            if (currentRound > maxRounds) {
                disableAllInvites();
                showCompletionDialog();
            }
        }

        function toggleAccordion(element) {
            const content = element.nextElementSibling;

            if (content.classList.contains("active")) {
                content.classList.remove("active");
                content.style.display = "none"; // Hide the content
            } else {
                content.classList.add("active");
                content.style.display = "flex"; // Show the content
            }
        }

        function getDefaultValue(group, candidate) {
            if (group.includes("gender")) {
                return candidate.Gender; // Use Gender directly
            } else if (group.includes("age")) {
                return getAgeBin(candidate.Age); // Calculate age bin
            } else if (group.includes("race")) {
                return candidate.Race; // Use Race directly from the fact sheet
            }
            return ""; // Default fallback
        }

        function getAgeBin(age) {
            
            if (age >= 20 && age <= 30) return "20-30";
            if (age >= 30 && age <= 40) return "30-40";
            if (age >= 40 && age <= 50) return "40-50";
            if (age >= 50 && age <= 60) return "50-60";
            if (age > 60) return ">60";

            console.warn(`‚ö†Ô∏è Age ${age} does not match any category.`);
            return ""; // Return empty string if no match
        }
        
        // Fetch candidates and set up interactivity after the profiles are rendered
        fetchCandidates();

        let hasFetchedCandidates = false;  // Prevent double fetch

        window.onload = async function () {
            console.log("üîÑ Performing FULL RESET...");

            // üîÑ Clear frontend tracking data
            localStorage.clear();
            invitedCount = 0;
            invitedCandidates = [];
            currentRound = 1;
            isFetching = false;

            // Update UI to show reset
            updateInviteCounter();

            try {
                // Wait for backend reset BEFORE fetching candidates
                console.log("üîÑ Requesting backend reset...");
                const response = await fetch("/candidates/reset", { method: "POST" });
                const data = await response.json();
                console.log("‚úÖ Backend Reset:", data);

                // Fetch fresh candidates only after reset is complete
                await fetchCandidates();
            } catch (error) {
                console.error("üö® Backend Reset Error:", error);
            }
        };

        async function inviteCandidate(candidateId, button) {
            if (currentRound > maxRounds) {
                disableAllInvites();
                showCompletionDialog();
                return;
            }

            const card = button.closest('.profile-card');
            if (!card) {
                console.error("‚ö†Ô∏è No profile card found for this button.");
                return;
            }

            if (!candidateId) {
                console.error("‚ö†Ô∏è Candidate ID missing on the profile card.");
                return;
            }

            if (invitedCount < maxInvites) {
                card.classList.add('invited');
                button.outerHTML = `<div class="badge-green">Invited</div>`;

                invitedCount++;
                invitedCandidates.push(candidateId);
                localStorage.setItem("invitedCandidates", JSON.stringify([...new Set(invitedCandidates)]));

                // Send to backend for persistence
                try {
                    const response = await fetch("/candidates/invite", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ candidate_id: candidateId })
                    });

                    if (!response.ok) {
                        console.error("‚ùå Error inviting candidate:", await response.text());
                    } else {
                        console.log(`‚úÖ Candidate ${candidateId} invited successfully.`);
                    }
                } catch (error) {
                    console.error("üö® Fetch error:", error);
                }

                updateInviteCounter();

                console.log(`‚úÖ Candidate ${candidateId} invited.`);

                if (invitedCount >= maxInvites) {
                    if (currentRound < maxRounds) { 
                        currentRound++; 
                        localStorage.setItem("currentRound", currentRound);
                    } else {
                        currentRound = maxRounds + 1;
                        localStorage.setItem("currentRound", currentRound);
                    }

                    // **Reset the invite counter for the new round**
                    invitedCount = 0;
                    localStorage.setItem("invitedCount", JSON.stringify(invitedCount));

                    updateInviteCounter();
                    
                    setTimeout(() => {
                        document.getElementById("profiles").innerHTML = ""; // **Clear the old candidates**
                        fetchCandidates(); // **Fetch new candidates immediately**
                    }, 500);
                }
            } else {
                alert('Maximum number of applicants invited!');
            }
        }

    </script>
</body>

</html>
