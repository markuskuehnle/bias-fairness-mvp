<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Applicant Profiles</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 0;
        }
    
        .header {
            background-color: #f8f9fa;
            color: #333;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    
        .header-content {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    
        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
        }
        
        .header-row h2 {
            margin: 0;
            font-size: 1.2em;
            color: #555;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.8em;
            color: #555;
        }
    
        .header h2 {
            margin: 5px 0 0 0;
            font-size: 1.2em;
            font-weight: normal;
            color: #777;
        }

    
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* Increased the gap between cards for better spacing */
            justify-content: center;
            padding: 20px;
            position: relative;
            overflow: visible;
        }
    
        .profile-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            overflow: visible; /* Prevent clipping of tooltip within the card */
            width: 220px; /* Slightly increased width for better readability */
            display: flex;
            flex-direction: column;
            position: relative; /* Ensure tooltip respects this card's positioning */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 1; 
        }
    
        .profile-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            z-index: 100;
        }
    
        .profile-card.invited {
            opacity: 0.6;
            pointer-events: none;
        }
    
        .profile-header {
            background-color: #f0f0f0;
            color: #333;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
            font-weight: bold;
        }
    
        .badge-container {
            height: 30px;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 10px;
        }
    
        .badge-yellow {
            background-color: #FFFACD;
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 100px;
            text-align: center;
        }
    
        .badge-green {
            background-color: #DFF2BF;
            color: #333;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.75em;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            min-width: 100px;
            text-align: center;
        }
    
        .profile-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            padding: 10px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
        }
    
        .profile-section div {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
    
        .profile-section div span:first-child {
            font-weight: bold;
        }
    
        .skills, .prediction-section, .invite-section {
            padding: 10px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
        }
    
        .invite-section {
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    
        .accordion-header {
            cursor: pointer;
            color: #007BFF;
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px 0;
        }
    
        .accordion-content {
            display: flex;
            flex-direction: column;
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-top: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
    
        .accordion-content.active {
            display: flex;
        }
    
        .accordion-content div {
            margin-bottom: 5px;
        }
    
        .info-icon {
            margin-left: 5px;
            font-size: 0.9em;
            color: #888;
            cursor: pointer;
            position: relative; /* Ensure tooltip is positioned relative to the icon */
            z-index: 2; /* Tooltip is above other cards */
        }
    
        .info-icon:hover::after {
            content: "These values represent the impact of features on the AI's decision-making process. Higher values indicate stronger influence.";
            position: absolute;
            top: -60px;
            left: 50%; /* Center the tooltip horizontally */
            transform: translateX(-50%); /* Adjust for tooltip width */
            background-color: #fff;
            color: #333;
            font-size: 0.8em;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px;
            width: 250px; /* Increased width for better readability */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000; /* Ensure tooltip is above other cards */
            white-space: normal;
            pointer-events: none;
        }
    
        .info-icon:hover {
            z-index: 1000; /* Bring the icon and tooltip above all cards */
        }
    
        .stars {
            color: #000;
        }
    
        .invite-btn {
            padding: 5px 10px;
            border: none;
            background-color: #FFFACD;
            color: #333;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em; 
            transition: background-color 0.3s ease;
        }
    
        .invite-btn.highlight-btn {
            background-color: #FFECB3;
        }
    
        .invite-btn.highlight-btn:hover {
            background-color: #FFE082;
        }
    
        .hoverable-feature {
            position: relative;
            cursor: pointer;
            color: #007BFF;
            text-decoration: underline dotted;
        }
    
        .hoverable-feature:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            top: -65px; /* Moves the tooltip further upward */
            left: 60%;  /* Shifts the tooltip to the right */
            transform: translateX(0); /* Removes the centering transformation */
            background-color: #fff;
            color: #333;
            font-size: 0.8em;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 5px 10px;
            width: 280px; /* Increased tooltip width */
            white-space: normal; 
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 9999;       /* High z-index to ensure it appears above other elements */
        }

        .recommendation-manipulation {
            padding: 15px;
            background-color: #f9f9f9;
            border-top: 1px solid #eee;
            margin-top: 15px;
            border-radius: 8px;
        }

        .manipulation-columns {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .manipulation-column {
            width: 30%; /* Ensure 3 columns fit in one row */
        }

        .manipulation-column h5 {
            margin-bottom: 10px;
            font-size: 1em;
            color: #555;
        }

        .manipulation-column label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
        }

        .manipulation-column input[type="radio"] {
            margin-right: 5px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #333;
            cursor: pointer;
        }

        button.highlighted {
            background-color: #f0f8ff; /* Light blue background */
            color: #333; /* Text color */
            border: 2px solid #007bff; /* Blue border */
            box-shadow: 0 0 10px rgba(0, 123, 255, 0.5); /* Glow effect */
            transition: all 0.3s ease; /* Smooth transition for the highlight */
        }

        label.disabled {
            opacity: 0.5; /* Grey out the label */
            pointer-events: none; /* Prevent interaction */
            cursor: not-allowed; /* Show a "not-allowed" cursor */
        }

        .good-fit-no {
            color: red;
            font-weight: bold;
        }

        .probability-low {
            color: red;
            font-weight: bold;
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .modal h2 {
            margin: 0 0 10px;
        }

        .modal button {
            padding: 10px 20px;
            border: none;
            background: #007BFF;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }

        .modal button:hover {
            background: #0056b3;
        }

        .next-round-btn {
            padding: 10px 15px;
            background-color: #007BFF;
            color: white;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .next-round-btn:hover {
            background-color: #0056b3;
        }

        .hidden { 
            display: none !important;
        }
        #intro {
            padding: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #intro .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 600px;
            text-align: left;
        }
        #intro h1 {
            color: #333;
            margin-bottom: 10px;
        }
        #intro p {
            color: #666;
            font-size: 1.1em;
            margin-bottom: 15px;
        }
        #intro .start-button {
            background-color: #007BFF;
            color: white;
            padding: 10px 20px;
            font-size: 1.1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #intro .start-button:hover {
            background-color: #0056b3;
        }
        #intro .role-description {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #intro .role-description strong {
            font-size: 1.1em;
            color: #555;
        }
    </style>
    
</head>
<body>
    <!-- Intro Section -->
    <div id="intro">
        <div class="container">
          <h1>Welcome to the Candidate Selection Process</h1>
          <p>
            Please review profiles of candidates applying for the <strong>Production Technician</strong> role.
            In each round, you will choose one candidate based on the profile details.
          </p>
          <ul>
            <li><strong>Name & Identity:</strong> Candidate’s full name and profile information.</li>
            <li>
                <strong>Skills, Certificates, and Competencies:</strong>
                Shown using star ratings (0–5), where 0 indicates low performance and 5 indicates excellent performance.
              </li>
        </ul>
          <div class="role-description">
            <h2>About the Role</h2>
            <p>
              Production Technicians ensure manufacturing operations run smoothly by operating equipment,
              maintaining quality, troubleshooting issues, and ensuring safety.
            </p>
          </div>
          <p>Click the button to start selecting candidates.</p>
      <button class="start-button" onclick="startApplication()">Start</button>
        </div>
      </div>
    
      <!-- Candidate Section (initially hidden) -->
    <div id="candidateSection" class="hidden">
        <div class="header">
            <div class="header-content">
                <h1>Applicant Profiles</h1>
                <div class="header-row">
                    <h2 id="invite-counter">Applicants invited: 0/2 · Round: 1/6</h2>
                    <button class="next-round-btn" onclick="nextRound()">Next Round</button>
                </div>            
            </div>
        </div>    

        <div class="container" id="profiles">
            <!-- Profiles will be injected here -->
        </div>
    </div>

    <script>
        let sessionData = {
            session_id: null,
            user_group: "features", // TODO: Change dynamically
            sessionTime: null,
            rounds: [],
            candidate_hover_events: {} // Initialize hover events mapping
        };
        let currentRoundCandidates = [];
        let lastRoundCandidates = [];
        let invitedCount = 0;
        const maxInvites = 1;
        const maxRounds = 6;
        let currentRound = parseInt(localStorage.getItem("currentRound")) || 1;
        let invitedCandidates = JSON.parse(localStorage.getItem("invitedCandidates")) || [];
        let isFetching = false;  // Global lock to prevent duplicate calls

        async function updatePrediction(candidateId, gender, age, race) {
            const updatePayload = {
                candidate_id: candidateId,
                updated_features: {
                    Sex: gender === "Female" ? 0 : 1,
                    Age: age
                }
            };

            // Reset all race values to 0
            const raceColumnMap = {
                "Black": "RaceDesc_Black or African American",
                "White": "RaceDesc_White",
                "Asian": "RaceDesc_Asian",
                "American Indian": "RaceDesc_American Indian or Alaska Native",
                "Hispanic": "RaceDesc_Hispanic"
            };
            Object.values(raceColumnMap).forEach(raceKey => updatePayload.updated_features[raceKey] = 0);

            // Set the selected race to 1
            if (raceColumnMap[race]) {
                updatePayload.updated_features[raceColumnMap[race]] = 1;
            }

            console.log("📤 Sending request to backend:", JSON.stringify(updatePayload));

            try {
                const response = await fetch("/predict/update", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(updatePayload)
                });

                console.log("🔄 Waiting for backend response...");

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error("❌ Backend returned an error:", errorText);
                    throw new Error("Failed to update prediction.");
                }

                const result = await response.json();
                console.log("✅ Backend response:", result);

                // Fetch feature descriptions
                const featureDescriptions = await fetchFeatureDescriptions();

                // Find the correct candidate profile card
                const candidateCard = document.querySelector(`.profile-card[data-candidate-id="${candidateId}"]`);
                if (!candidateCard) {
                    console.error("❌ Candidate card not found for ID:", candidateId);
                    return;
                }

                // Update the Good Fit section correctly
                const goodFitElement = candidateCard.querySelector(".prediction-section strong:nth-of-type(1)");
                if (goodFitElement) {
                    goodFitElement.nextSibling.nodeValue = ` ${result.is_good_fit ? "Yes" : "No"}`;
                    if (!result.is_good_fit) {
                        goodFitElement.classList.add("good-fit-no"); // Apply red color for "No"
                    } else {
                        goodFitElement.classList.remove("good-fit-no"); // Remove red color for "Yes"
                    }
                }

                // Update the Probability correctly
                const probabilityElement = candidateCard.querySelector(".prediction-section div:nth-of-type(2) strong");
                if (probabilityElement) {
                    probabilityElement.nextSibling.nodeValue = ` ${result.prediction_probability.toFixed(2)}`;
                    if (result.prediction_probability < 0.5) {
                        probabilityElement.classList.add("probability-low"); // Apply red color for low probability
                    } else {
                        probabilityElement.classList.remove("probability-low"); // Remove red color if above threshold
                    }
                }   

                // Update the AI Recommendation Badge (Add/Remove)
                const badgeContainer = candidateCard.querySelector(".badge-container");
                if (result.is_good_fit) {
                    // Add AI Recommendation badge if it doesn't exist
                    if (!badgeContainer.querySelector(".badge-yellow")) {
                        badgeContainer.innerHTML = `<div class="badge-yellow">AI Recommendation</div>`;
                    }
                } else {
                    // Remove AI Recommendation badge if Good Fit is No
                    const aiBadge = badgeContainer.querySelector(".badge-yellow");
                    if (aiBadge) {
                        aiBadge.remove();
                    }
                }

                // Update the invite button text and styling based on GoodFit
                const inviteButton = candidateCard.querySelector(".invite-btn");
                if (result.is_good_fit) {
                    inviteButton.textContent = ">>Invite Applicant<<";
                    inviteButton.classList.add("highlight-btn");
                } else {
                    inviteButton.textContent = "Invite Applicant";
                    inviteButton.classList.remove("highlight-btn");
                }

                // Update the XAI explanation
                const xaiSection = candidateCard.querySelector(".accordion-content");
                if (xaiSection) {
                    xaiSection.innerHTML = result.top_features.map(feature => {
                        const description = featureDescriptions[feature.Feature] || "No description available.";
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="hoverable-feature" title="${description}">
                                    ${feature.Feature}:
                                </span>
                                <span>${feature["SHAP Value"].toFixed(2)}</span>
                            </div>
                        `;
                    }).join('');
                }

            } catch (error) {
                console.error("🚨 Fetch error:", error);
            }
        }

        function getRandomAge(ageRange) {
            const ranges = {
                "20-30": [20, 30],
                "30-40": [30, 40],
                "40-50": [40, 50],
                ">60": [61, 75]
            };

            if (ranges[ageRange]) {
                const [min, max] = ranges[ageRange];
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            return 35; // Default fallback
        }

        async function handleManipulationChange(candidateId, selectedGroup, selectedValue, originalValues) {
            console.log("🔹 handleManipulationChange triggered", candidateId, selectedGroup, selectedValue);

            const allInputs = document.querySelectorAll(`input[name^="gender-${candidateId}"], 
                                                        input[name^="age-${candidateId}"], 
                                                        input[name^="race-${candidateId}"]`);

            // Get the original values
            const originalGender = originalValues.gender;
            const originalAge = originalValues.age;
            const originalRace = originalValues.race;

            // Check if a radio button is selected before accessing `.value`
            const genderInput = document.querySelector(`input[name="gender-${candidateId}"]:checked`);
            const ageInput = document.querySelector(`input[name="age-${candidateId}"]:checked`);
            const raceInput = document.querySelector(`input[name="race-${candidateId}"]:checked`);

            console.log(`🟢 Found selections - Gender: ${genderInput ? genderInput.value : "❌ MISSING"}, Age: ${ageInput ? ageInput.value : "❌ MISSING"}, Race: ${raceInput ? raceInput.value : "❌ MISSING"}`);

            // If any input is missing, log an error and return
            if (!genderInput || !ageInput || !raceInput) {
                console.error(`⚠️ Missing input selection for candidate ${candidateId}`);
                return;
            }

            const currentGender = genderInput.value;
            const currentAge = ageInput.value;
            const currentRace = raceInput.value;

            console.log("Current selections:", currentGender, currentAge, currentRace);

            const isReverted = currentGender === originalGender && currentAge === originalAge && currentRace === originalRace;

            if (!isReverted) {
                console.log("Modifications detected, updating prediction...");
                allInputs.forEach(input => {
                    if (input.name.includes(selectedGroup) || input.value === originalValues[selectedGroup]) return;
                    input.disabled = true;
                    input.parentElement.classList.add("disabled");
                });

                await updatePrediction(candidateId, currentGender, currentAge, currentRace);
            } else {
                console.log("Values reverted, enabling inputs...");
                allInputs.forEach(input => {
                    input.disabled = false;
                    input.parentElement.classList.remove("disabled");
                });

                await updatePrediction(candidateId, originalGender, originalAge, originalRace);
            }
        }

        document.addEventListener("change", function (event) {
            if (event.target.type === "radio") {
                const candidateId = event.target.name.split('-')[1]; // Extract Candidate_ID
                const selectedGroup = event.target.name.split('-')[0]; // e.g., "gender", "age", "race"
                const selectedValue = event.target.value;

                // Find the profile card and get the original values
                const card = event.target.closest('.profile-card');
                if (!card) return;

                const originalValues = {
                    gender: card.dataset.originalGender,
                    age: card.dataset.originalAge,
                    race: card.dataset.originalRace,
                };

                handleManipulationChange(candidateId, selectedGroup, selectedValue, originalValues);
            }
        });

        document.addEventListener("DOMContentLoaded", function () {
            document.querySelectorAll(".accordion-content").forEach(content => {
                content.classList.add("active"); // Ensures all accordions start open
            });
        });

        document.getElementById("profiles").addEventListener("mouseover", function(e) {
            if (e.target.classList.contains("hoverable-feature")) {
                // Record the hover start time if not already set.
                if (!e.target.dataset.hoverStart) {
                    e.target.dataset.hoverStart = Date.now();
                }
            }
        });

        document.getElementById("profiles").addEventListener("mouseout", function(e) {
            if (e.target.classList.contains("hoverable-feature")) {
                if (e.target.dataset.hoverStart) {
                    // Calculate the hover duration.
                    let hoverTime = Date.now() - parseInt(e.target.dataset.hoverStart);
                    // Get candidate id from the closest parent profile card.
                    let candidateId = e.target.closest(".profile-card").getAttribute("data-candidate-id");
                    // Get the feature name by stripping any trailing colon and whitespace.
                    let featureName = e.target.textContent.replace(":", "").trim();
                    // Initialize candidate's hover events array if not already set.
                    if (!sessionData.candidate_hover_events[candidateId]) {
                        sessionData.candidate_hover_events[candidateId] = [];
                    }
                    // Save the hover event.
                    sessionData.candidate_hover_events[candidateId].push({
                        feature: featureName,
                        hover_duration: hoverTime
                    });
                    // Clean up.
                    delete e.target.dataset.hoverStart;
                }
            }
        });


        async function fetchCandidates() {
            if (currentRound > maxRounds) {
                console.log("Max rounds reached. Not fetching any more candidates.");
                await endSession();
                disableAllInvites();
                showCompletionDialog();
                return;
            }
            try {
                if (isFetching) {
                    console.warn("🚫 Skipping duplicate fetchCandidates call.");
                    return; // Prevent a second call
                }

                isFetching = true; // Set the lock
                currentRoundCandidates.length = 0;

                // Retrieve the seenCandidates list
                let seenCandidates = JSON.parse(localStorage.getItem("seenCandidates")) || [];
                let invitedCandidates = JSON.parse(localStorage.getItem("invitedCandidates")) || [];
                console.log("📌 LocalStorage seenCandidates:", JSON.parse(localStorage.getItem("seenCandidates")) || []);
                console.log("📌 LocalStorage invitedCandidates:", JSON.parse(localStorage.getItem("invitedCandidates")) || []);

                // Combine seen and invited candidates for exclusion
                let excludeList = [...new Set(seenCandidates.concat(invitedCandidates))];

                console.log("📤 Fetching candidates. Excluding:", excludeList);

                // Ensure we send exclude correctly formatted
                const queryString = excludeList.length > 0 
                    ? `?exclude=${excludeList.join("&exclude=")}` 
                    : "";

                // Fetch candidates and feature descriptions in parallel
                const [candidatesResponse, featureDescriptions] = await Promise.all([
                    fetch(`/candidates/data${queryString}`).then(res => res.json()), // Fetch candidates
                    fetchFeatureDescriptions() // Fetch feature descriptions
                ]);

                // Handle errors if candidates response fails
                if (!candidatesResponse) {
                    throw new Error("Failed to fetch candidates.");
                }

                const data = candidatesResponse; // Assign the JSON response

                // Extract new candidate IDs
                let newSeenCandidates = data.map(c => c.Candidate_ID);
                
                // Ensure `seenCandidates` updates correctly
                seenCandidates = [...new Set([...seenCandidates, ...newSeenCandidates])]; 
                localStorage.setItem("seenCandidates", JSON.stringify(seenCandidates));

                updateInviteCounter();

                // Select the container where profiles will be displayed
                const profilesContainer = document.getElementById('profiles');
                profilesContainer.innerHTML = ''; // Clear previous content
                        
                // Store the newly fetched candidates as "seen"
                currentRoundCandidates = [];
                // localStorage.setItem("seenCandidates", JSON.stringify([...new Set(seenCandidates.concat(currentRoundCandidates))]));

                // Iterate through each candidate
                data.forEach(candidate => {
                    currentRoundCandidates.push({
                        candidate_id: candidate.Candidate_ID,
                        name: candidate.Prename + " " + candidate.Name,
                        attributes: {
                        age: candidate.Age || "N/A",
                        sex: candidate.Gender,
                        race: candidate.Race,
                        years_experience: candidate.Skills.YearsExperience || 0,
                        technical_skills_score: candidate.Skills.TechnicalSkills || 0,
                        certifications_score: candidate.Skills.Certifications || 0
                        },
                        good_fit: candidate.GoodFit,
                        recommended: candidate.GoodFit,
                        invited: false,
                        manipulated: false
                    });
                    lastRoundCandidates = JSON.parse(JSON.stringify(currentRoundCandidates));

                    const card = document.createElement('div');
                    card.setAttribute('data-candidate-id', candidate.Candidate_ID);
                    card.className = 'profile-card';

                    // Store the original values in data attributes
                    card.dataset.originalGender = candidate.Gender;
                    card.dataset.originalAge = getAgeBin(candidate.Age);
                    card.dataset.originalRace = candidate.Race;

                    // Add AI Recommendation badge if applicable
                    const badge = candidate.GoodFit
                        ? `<div class="badge-yellow">AI Recommendation</div>`
                        : "";

                    // Generate accordion content for XAI features
                    const accordionContent = candidate.GoodFit
                        ? generateAccordionContent(candidate, featureDescriptions)
                        : '';

                    // Build the card HTML
                    card.innerHTML = `
                        <div class="profile-header">
                            <span>${candidate.Prename} ${candidate.Name}</span>
                        </div>
                        <div class="badge-container">${badge}</div>

                        <div class="profile-section">
                            <div>
                                <span>Name:</span>
                                <span>${candidate.Name}</span>
                            </div>
                            <div>
                                <span>Prename:</span>
                                <span>${candidate.Prename}</span>
                            </div>
                            <div>
                                <span>Gender:</span>
                                <span>${candidate.Gender}</span>
                            </div>
                            <div>
                                <span>Age:</span>
                                <span>${candidate.Age || 'N/A'}</span>
                            </div>
                            <div>
                                <span>Nationality:</span>
                                <span>${candidate.Nationality || 'N/A'}</span>
                            </div>
                            <div>
                                <span>Birthplace:</span>
                                <span>${candidate.Birthplace || 'N/A'}</span>
                            </div>
                        </div>

                        <div class="skills">
                            <h4>Skills:</h4>
                            ${Object.entries(candidate.Skills).map(([skill, stars]) => `
                                <div style="display: flex; justify-content: space-between;">
                                    <span>${skill}</span>
                                    <span class="stars">${'★'.repeat(stars)}${'☆'.repeat(5 - stars)}</span>
                                </div>
                            `).join('')}
                        </div>

                        <div class="invite-section"></div> <!-- Invite button will be appended here -->

                        <div class="prediction-section">
                            <div>
                                <strong>Good Fit?:</strong> ${candidate.GoodFit ? "Yes" : "No"}
                            </div>
                            <div>
                                <strong>Probability:</strong> ${candidate.Probability ? candidate.Probability.toFixed(2) : "0.00"}
                            </div>
                        </div>

                        ${accordionContent}

                        ${candidate.GoodFit ? `
                            <div class="recommendation-manipulation">
                                <h4>Manipulate AI Recommendation:</h4>
                                <strong>Take a look at how the recommendation changes when you manipulate protected data:</strong>
                                <div class="manipulation-columns">
                                    <div class="manipulation-column">
                                        <h5>Gender</h5>
                                        ${["Male", "Female"].map(value => `
                                            <label>
                                                <input type="radio" name="gender-${candidate.Candidate_ID}" value="${value}"
                                                    ${candidate.Gender === value ? "checked" : ""}>
                                                ${value}
                                            </label>
                                        `).join('')}
                                    </div>

                                    <div class="manipulation-column">
                                        <h5>Age</h5>
                                        ${["20-30", "30-40", "40-50", "50-60", ">60"].map(value => `
                                            <label>
                                                <input type="radio" name="age-${candidate.Candidate_ID}" value="${value}"
                                                    ${getAgeBin(candidate.Age) === value ? "checked" : ""}>
                                                ${value} years
                                            </label>
                                        `).join('')}
                                    </div>

                                    <div class="manipulation-column">
                                        <h5>Race</h5>
                                        ${["Black", "White", "Asian"].map(value => `
                                            <label>
                                                <input type="radio" name="race-${candidate.Candidate_ID}" value="${value}"
                                                    ${candidate.Race === value ? "checked" : ""}>
                                                ${value}
                                            </label>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        ` : ""}

                    `;

                    // **Create Invite Button**
                    const inviteButton = document.createElement("button");
                        inviteButton.className = candidate.GoodFit ? "invite-btn highlight-btn" : "invite-btn";
                        inviteButton.textContent = candidate.GoodFit ? ">>Invite Applicant<<" : "Invite Applicant";
                        inviteButton.addEventListener("click", function () {
                            inviteCandidate(candidate.Candidate_ID, inviteButton);
                        });

                    // Append the invite button to the card
                    card.querySelector(".invite-section").appendChild(inviteButton);

                    // Append the card to the profiles container
                    profilesContainer.appendChild(card);
                });
            } catch (error) {
                console.error('Error fetching candidates:', error);
            } finally {
                isFetching = false; // Unlock after fetch completes
            }
        }

        // Helper function to fetch feature descriptions
        async function fetchFeatureDescriptions() {
            try {
                const response = await fetch('/data/feature_description.json');
                if (!response.ok) {
                    throw new Error('Failed to load feature descriptions');
                }
                return await response.json(); // Parse and return JSON
            } catch (error) {
                console.error('Error fetching feature descriptions:', error);
                return {};
            }
        }

        function generateAccordionContent(candidate, featureDescriptions) {
            if (!candidate.GoodFit) return '';

            return `
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    XAI: Top 3 Features
                    <span class="info-icon" data-tooltip="These values represent the top factors influencing the AI's decision-making. Higher values indicate stronger influence.">ℹ</span>
                </div>
                <div class="accordion-content">
                    ${candidate.TopFeatures.map(feature => {
                        const description = featureDescriptions[feature.Feature] || 'No description available.';
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span class="hoverable-feature" data-tooltip="${description}">
                                    ${feature.Feature}:
                                </span>
                                <span>${feature["SHAP Value"].toFixed(2)}</span>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function disableAllInvites() {
            document.querySelectorAll(".invite-btn").forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = "0.5";
                btn.style.cursor = "not-allowed";
            });
        }

        function showCompletionDialog() {
            const profilesContainer = document.getElementById("profiles");
            let elapsedDisplay = "";
            if (sessionElapsedSeconds !== null) {
                elapsedDisplay = `<p>Your session lasted ${sessionElapsedSeconds} seconds.</p>`;
            } else {
                elapsedDisplay = `<p>Session time not available.</p>`;
            }
            profilesContainer.innerHTML = `
                <div class="completion-message">
                    <h2>All Candidates Selected</h2>
                    <p>Thank you for your participation.</p>
                    ${elapsedDisplay}
                </div>
            `;
            const nextRoundButton = document.querySelector(".next-round-btn");
            if (nextRoundButton) {
                nextRoundButton.style.display = "none";
            }
        }

        function closeCompletionDialog() {
            // Instead of clearing the dialog, disable the OK button to indicate that the session is finished.
            const okButton = document.querySelector('.completion-message button');
            if (okButton) {
                okButton.disabled = true;
                okButton.textContent = "Session Ended";
            }
            // The dialog content (including the elapsed time) remains on screen.
        }

        function updateInviteCounter() {
            const inviteCounter = document.getElementById('invite-counter');

            // Hide the counter initially to prevent incorrect display
            inviteCounter.style.visibility = "hidden";

            // Ensure values are fetched from localStorage or set default values
            const displayedInvitedCount = Math.min(invitedCount, maxInvites);
            const displayedRound = Math.min(currentRound, maxRounds);

            // Update counter text
            inviteCounter.textContent = 
                `Applicants invited: ${displayedInvitedCount}/${maxInvites} · Round: ${displayedRound}/${maxRounds}`;

            // Show the counter only after correct values are set
            inviteCounter.style.visibility = "visible";
        }

        function toggleAccordion(element) {
            const content = element.nextElementSibling;

            if (content.classList.contains("active")) {
                content.classList.remove("active");
                content.style.display = "none"; // Hide the content
            } else {
                content.classList.add("active");
                content.style.display = "flex"; // Show the content
            }
        }

        function getDefaultValue(group, candidate) {
            if (group.includes("gender")) {
                return candidate.Gender; // Use Gender directly
            } else if (group.includes("age")) {
                return getAgeBin(candidate.Age); // Calculate age bin
            } else if (group.includes("race")) {
                return candidate.Race; // Use Race directly from the fact sheet
            }
            return ""; // Default fallback
        }

        function getAgeBin(age) {
            
            if (age >= 20 && age <= 30) return "20-30";
            if (age >= 30 && age <= 40) return "30-40";
            if (age >= 40 && age <= 50) return "40-50";
            if (age >= 50 && age <= 60) return "50-60";
            if (age > 60) return ">60";

            console.warn(`⚠️ Age ${age} does not match any category.`);
            return ""; // Return empty string if no match
        }

        function attachHoverEventsToCandidates(candidatesArray) {
            candidatesArray.forEach(candidate => {
                // Use the candidate's id as a string
                let cid = String(candidate.candidate_id);
                // If no hover events exist for this candidate, set to an empty array.
                candidate.hover_events = sessionData.candidate_hover_events && sessionData.candidate_hover_events[cid] 
                    ? sessionData.candidate_hover_events[cid] 
                    : [];
            });
        }

        // Fetch candidates and set up interactivity after the profiles are rendered
        fetchCandidates();

        let hasFetchedCandidates = false;  // Prevent double fetch

        // Ensure the invite counter is updated only after fetching candidates
        window.onload = async function () {
            console.log("🔄 Performing FULL RESET...");
            document.getElementById("invite-counter").style.visibility = "hidden";
            localStorage.clear();
            let sessionData = {
                session_id: null,
                user_group: "features", // TODO: Change dynamically
                sessionTime: null,
                rounds: [],
                candidate_hover_events: {} // Initialize hover events mapping
            };
            invitedCount = 0;
            invitedCandidates = [];
            currentRound = 1;
            isFetching = false;
            document.getElementById("profiles").innerHTML = "";
            try {
                console.log("🔄 Requesting backend reset...");
                const response = await fetch("/candidates/reset", { method: "POST" });
                const data = await response.json();
                console.log("✅ Backend Reset:", data);
                localStorage.setItem("seenCandidates", JSON.stringify([]));
                localStorage.setItem("invitedCandidates", JSON.stringify([]));
                localStorage.setItem("currentRound", "1");
                localStorage.setItem("invitedCount", "0");
                await fetchCandidates();
                updateInviteCounter();
            } catch (error) {
                console.error("🚨 Backend Reset Error:", error);
            }
        };

        async function inviteCandidate(candidateId, button) {
            console.log("inviteCandidate called");
            if (currentRound > maxRounds) {
                disableAllInvites();
                showCompletionDialog();
                return;
            }
            const card = button.closest('.profile-card');
            if (!card) {
                console.error("⚠️ No profile card found for this button.");
                return;
            }
            if (!candidateId) {
                console.error("⚠️ Candidate ID missing on the profile card.");
                return;
            }
            if (invitedCount < maxInvites) {
                // Mark candidate as invited visually
                card.classList.add('invited');
                button.outerHTML = `<div class="badge-green">Invited</div>`;
                
                // Update invite counters and session data
                invitedCount++;
                invitedCandidates.push(candidateId);
                localStorage.setItem("invitedCandidates", JSON.stringify([...new Set(invitedCandidates)]));
                currentRoundCandidates = currentRoundCandidates.map(cand =>
                cand.candidate_id === candidateId ? { ...cand, invited: true } : cand
                );
                
                // Send invitation to the backend
                try {
                const response = await fetch("/candidates/invite", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ candidate_id: candidateId })
                });
                if (!response.ok) {
                    console.error("❌ Error inviting candidate:", await response.text());
                } else {
                    console.log(`✅ Candidate ${candidateId} invited successfully.`);
                }
                } catch (error) {
                console.error("🚨 Fetch error:", error);
                }
                updateInviteCounter();
                console.log(`✅ Candidate ${candidateId} invited.`);
                // Attach hover events to each candidate in currentRoundCandidates.
                attachHoverEventsToCandidates(currentRoundCandidates);
                // When maximum invites for the round are reached,
                const roundEndTime = Date.now();
                const roundDuration = (roundEndTime - roundStartTime) / 1000;
                // push the current round's data into sessionData and move to the next round.
                if (invitedCount >= maxInvites) {
                    // Attach hover events to each candidate in currentRoundCandidates.
                    attachHoverEventsToCandidates(currentRoundCandidates);
                    sessionData.rounds.push({
                        round_number: currentRound,
                        candidate_count: currentRoundCandidates.length,
                        invited_count: invitedCandidates.length,
                        round_duration: roundDuration,
                        next_round_clicked: false, // This flag can later be updated in the nextRound function
                        candidates: JSON.parse(JSON.stringify(currentRoundCandidates)) // deep copy
                    });
                    currentRound++;
                    localStorage.setItem("currentRound", currentRound);
                    roundStartTime = Date.now();
                    invitedCount = 0;
                    localStorage.setItem("invitedCount", JSON.stringify(invitedCount));
                    updateInviteCounter();
                    // Clear candidate hover events for the next round.
                    sessionData.candidate_hover_events = {};
                    setTimeout(() => {
                        document.getElementById("profiles").innerHTML = "";
                        fetchCandidates();
                    }, 500);
                    }
                } else {
                alert('Maximum number of applicants invited!');
                }
            }

        // Global variables for session management.
        let sessionId = null;
        let sessionElapsedSeconds = null;

        // Function to start a new session by calling the backend.
        async function startSession(userId = null) {
            const payload = userId ? { user_id: userId } : {};
            try {
            const response = await fetch("/session/start", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            const data = await response.json();
            sessionId = data.session_id;
            sessionData.session_id = sessionId;
            console.log("Session started:", data);
            } catch (error) {
            console.error("Error starting session:", error);
            }
        }

        // Function to end the session by calling the backend.
        async function endSession() {
            try {
                if (!sessionId) {
                    console.error("🚨 No session ID found! Unable to end session.");
                    return;
                }
            } catch (error) {
                console.error("No session id found");
            }            
            try {
                console.log("🔄 Ending session with sessionId:", sessionId);
                const response = await fetch("/session/end", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ session_id: sessionId })
                });
                const data = await response.json();
                console.log("✅ Session successfully ended. Duration:", data.elapsed_seconds, "seconds");
                sessionElapsedSeconds = data.elapsed_seconds;
                sessionData.sessionTime = sessionElapsedSeconds;
            } catch (error) {
                console.error("🚨 Error ending session:", error);
                sessionElapsedSeconds = "unknown"; 
            }
        }

        function startApplication() {
            console.log("startApplication triggered");
            startSession(); // Start the session.
            roundStartTime = Date.now();
            document.getElementById("intro").classList.add("hidden");
            document.getElementById("candidateSection").classList.remove("hidden");
        }

        async function nextRound() {
            const roundEndTime = Date.now();
            const roundDuration = (roundEndTime - roundStartTime) / 1000;
            // Attach hover events to each candidate in lastRoundCandidates.
            attachHoverEventsToCandidates(lastRoundCandidates);
            sessionData.rounds.push({
                round_number: currentRound,
                candidate_count: lastRoundCandidates.length,
                invited_count: invitedCandidates.length,
                round_duration: roundDuration,
                next_round_clicked: true, 
                candidates: lastRoundCandidates 
            });
            // Clear candidate hover events for the round.
            sessionData.candidate_hover_events = {};
            console.log("DEBUG:", sessionData)
            currentRound++;
            localStorage.setItem("currentRound", currentRound);
            roundStartTime = Date.now();

            if (currentRound > maxRounds) {
                console.log("🏁 Final round reached. Ending session.");
                await endSession();
                disableAllInvites();
                showCompletionDialog();
                return;
            }
            invitedCount = 0;
            localStorage.setItem("invitedCount", JSON.stringify(invitedCount));
            document.getElementById("profiles").innerHTML = "";
            fetchCandidates();
            updateInviteCounter();
        }

        // Update the completion dialog to display the elapsed session time.
        function showCompletionDialog() {
            const profilesContainer = document.getElementById("profiles");
            let elapsedDisplay = "";
            if (sessionElapsedSeconds !== null) {
                elapsedDisplay = `<p>Your session lasted ${sessionElapsedSeconds} seconds.</p>`;
                console.log("Elapsed time:", sessionElapsedSeconds, "seconds");
            } else {
                elapsedDisplay = `<p>Session time not available.</p>`;
            }
            // Add a placeholder link to google.com after the elapsed time.
            const linkHTML = `<p><a href="https://www.google.com">Go to Google</a></p>`;
            const sessionDataHTML = `<pre>${JSON.stringify(sessionData, null, 2)}</pre>`;

            profilesContainer.innerHTML = `
                <div class="completion-message">
                    <h2>All Candidates Selected</h2>
                    <p>Thank you for your participation.</p>
                    ${elapsedDisplay}
                    ${linkHTML}
                    ${sessionDataHTML}
                </div>
            `;
            // Hide the next round button.
            const nextRoundButton = document.querySelector(".next-round-btn");
            if (nextRoundButton) {
                nextRoundButton.style.display = "none";
            }
        }

    </script>
</body>

</html>
